# Modules, monoliths, and microservices

> 原文地址: <https://tailscale.com/blog/modules-monoliths-and-microservices/>

1. 过去几十年间，人们通过“盒子”(box)和“箭头”(arrow) 来对软件系统建模，用盒子表示模块，箭头表示接口（模块之间的交互关系），作者认为这个方法带来了很多不必要的复杂性(mess)。
2. 模块化系统的目的
   1. 将相模块和其他模块分离开
   2. 将分离后的模块之间通过显式的预期关联起来
   3. 保证修改一个模块，和剩余的模块之间依赖兼容
   4. 升级、降级、伸缩某些模块时，不必同时改动其他模块

3. 在模块化方面，目前在“隔离”上做的最差，在不同的抽象层次、实现技术上总是会出现打破隔离的 case，并且人们总是陷入到乐观到绝望的循环怪圈里
   1. 如果攻击者能向你的代码里链接 lib，则有可能修改机器上的任何数据

   2. 如何攻击者能写数据库，则有可能写数据库的任何地方

4. 因为隔离性很难做到完美，因此直到这些悲观的 case，能让我们避免为了追求隔离性而将系统设计得过于复杂

5. 模块边界可以分为可信的弱隔离，和不可信的强隔离，弱隔离的模块间互相信任(DDL)，强隔离的模块间互相不信任（sanbox）
6. 开发者不会处于安全原因来定义模块边界，而通常会遵循康威定理（基于组织架构）
7. 模块边界只定义模块之间如何交互，不定义模块部署单元的大小，而“单体服务”和“微服务”的区别只是部署单元大小的区别，单体应用只有一个部署单元，而微服务有很多个
8. 服务边界应该设置在哪
   1. 隔离性：如果处于安全的诉求，在模块之间需要强隔离，而非架构目标
   2. 连接性：遵循康威定理，符合团队交流的模式
   3. 兼容性保证：促使使用单体应用来部署，从而获得良好的兼容性
   4. 升级、降级、伸缩
9. 选择服务边界时需要考虑的条件
   1. 单体应用是否启动耗时很久
   2. 是否需要正确的数据存储 schema 版本
   3. 集成测试是否频繁失败，越频繁越倾向拆服务
   4. 模块之间是否有独立伸缩的需求
   5. 是否有昂贵的请求需要更少的并行度？ see [avoid queue explosion](http://cpitman.github.io/microservices/2018/03/25/microservice-antipattern-queue-explosion.html)
   6. 不同的服务之间，是否有不同的质量和稳定性要求？
